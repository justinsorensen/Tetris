<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>Tetris</title>
  <style>
    html, body, canvas {
      margin: 0;
      padding: 0
    }
    html, body { 
      width:100%; 
      height:100%; 
      overflow:hidden;
    }
  </style>
</head>

<body>
  <canvas id="canvas" width="250" height="450"></canvas>
  
  <script type="text/javascript" src ="kibo.js"></script>
  <script type="text/javascript"> 
    var CELL_SIZE = 25;
    var INTERVAL = 600; // milliseconds
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var inactiveBlocks = [];
    //var activeBlock = new Block(0);
	//var blockRotate = [[0,-1],[0,0],[0,1],[0,2]];		//attempting to implement offsets as suggested by Dr. Turner
	
	//var blockRotate = [-1,0,1,2];
	
	var blockRotate = new Array();
	blockRotate = [-1,0,1,2];

	/*blockRotate = {
		0:[[0,-1],[0,0],[0,1],[0,2]]
	}*/
	
	//Line Block
	/*blockRotate[0] = [
		[[0,-1],[0,0],[0,1],[0,2]],
		[[-1,0],[0,0],[1,0],[2,0]],
		[[0,-2],[0,-1],[0,0],[0,1]],
		[[-2,0],[-1,0],[0,0],[1,0]] 
	];*/
	//blockRotate[0][0] = [[0,-1],[0,0],[0,1],[0,2]];
	
	var activeBlock = new Block(0);
	
	
    function clearGrid() {
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, 10 * CELL_SIZE, 18 * CELL_SIZE);
    }
	
	//***********Cell definition begin *******************
    function Cell(x, y) {
      this.x = x;
      this.y = y;
	  this.draw = function() {
		ctx.fillStyle = '#000000';
		ctx.fillRect(this.x * CELL_SIZE, this.y * CELL_SIZE, 25, 25);
	  }
	  
	  this.drop = function() {
		++this.y;
		console.log('dropped cell');
	  }
	  
	  this.shiftLeft = function() {
		--this.x;
	  }
	  
	  this.shiftRight = function() {
		++this.x;
	  }
	  
    }
	//************* Cell definition end ***********************

	
	//************* Block definition begin*********************
	
    function Block(blockType) {
      this.type = blockType;
      this.cells = [];
      this.x = 5;
      this.y = 0;
	  this.rotating = 0;
	  
		  for(var i = 0; i < 4; i++) {		//index position definitions [block type][which rotation][which block][x or y]
			this.cells.push(new Cell(this.x, this.y + blockRotate[i]));
			//this.cells.push(new Cell(this.x + blockRotate[this.type][this.rotating][i][1], this.y + blockRotate[this.type][this.rotating][i][1]*/));
			//console.log(blockRotate[0][0]);
		  }
		  
	  
	  
	  
      /*if (this.type === 0) {						//Old block creation, NEED TO DELETE.
        this.cells.push(new Cell(this.x, this.y));
        this.cells.push(new Cell(this.x, this.y - 1));
        this.cells.push(new Cell(this.x, this.y - 2));
        this.cells.push(new Cell(this.x, this.y - 3));
      } */
	  
	  this.draw = function() {
        for (var i = 0; i < this.cells.length; ++i) {
			this.cells[i].draw();
		}
	  }
	  
	  /*this.draw = function() {
			if (this.type === 0) {
				for (var i = 0; i < 4; ++i) this.cells[i].draw();
        
			}
	  }*/
	  
	  /*this.drop = function() {
		++this.y;
		console.log('dropped block');
		for(var i = 0; i < this.cells.length; i++) {
			this.cells[i].draw();
		}
	  }*/
	  
	  
	  //****************moveFunctions need collision check******************
	  this.canMoveLeft = function() {
	    for(var i = 0; i < inactiveBlocks.length; i++) {
		  if(activeBlock.wouldCollideLeft(inactiveBlocks[i])) { 
			return false;
			console.log('canMoveLeft == false');
		  }
		return true;
		}
	  }
	  
	  
	  this.moveLeft = function() {
		for(var i = 0; i < this.cells.length; i++) {
			if(this.cells[i].x <=0) {
				return false;
				console.log('moveLeft == false');
			}
			if(activeBlock.canMoveLeft()) {	
				for(var i = 0; i < this.cells.length; i++) {
					this.cells[i].shiftLeft();
					this.x--;
				}
			}
		}
	  }
	  
	  this.canMoveRight = function() {
	    for(var i = 0; i < inactiveBlocks.length; i++) {
		  if(activeBlock.wouldCollideRight(inactiveBlocks[i])) {
			return false;
			console.log('canMoveRight == false');
		  }
	    }
		return true;
	  }
	  
	  this.moveRight = function() {
		for(var i = 0; i < this.cells.length; i++) {
			if(this.cells[i].x >=9) {
				return false;
				console.log('moveRight == false');
			}
			if(activeBlock.canMoveRight()) {	
				for(var i = 0; i < this.cells.length; i++) {
					this.cells[i].shiftRight();
					this.x++;
				}
			}
		}
	  }
    
	}
	//***************Block definition end ************************
	

    Block.prototype.draw = function() {
      if (this.type === 0) {
        for (var i = 0; i < 4; ++i) this.cells[i].draw();
        
      }
    };

    Block.prototype.wouldCollideDown = function(otherBlock) {		//Down collision check
      for (var i = 0; i < 4; ++i) {
        var cell = this.cells[i];
        for (var j = 0; j < 4; ++j) {
          var otherCell = otherBlock.cells[j];
          if (otherCell.x == cell.x && otherCell.y == cell.y + 1) {
            return true;
          }
        }
      }
      return false;
    };
	
	Block.prototype.wouldCollideRight = function(otherBlock) {		//Right collision check
      for (var i = 0; i < 4; ++i) {
        var cell = this.cells[i];
        for (var j = 0; j < otherBlock.cells.length; ++j) {
          var otherCell = otherBlock.cells[j];
          if (otherCell.x == cell.x + 1 && otherCell.y == cell.y) {
            return true;
			console.log('wouldCollideRight == true');
          }
        }
      }
      return false;
    };
	
	Block.prototype.wouldCollideLeft = function(otherBlock) {		//Left collision check
      for (var i = 0; i < 4; ++i) {
        var cell = this.cells[i];
        for (var j = 0; j < otherBlock.cells.length; ++j) {
          var otherCell = otherBlock.cells[j];
          if (otherCell.x == cell.x - 1 && otherCell.y == cell.y) {
            console.log('wouldCollideLeft == true');
			return true;
          }
        }
      }
      return false;
    };

    Block.prototype.drop = function() {
      ++this.y;
      for (var i = 0; i < 4; ++i) this.cells[i].drop();
    };

    Block.prototype.canDrop = function() {
      if (this.y >= 17) {
        return false;
      }
      for (var i = 0; i < inactiveBlocks.length; ++i) {
        if (activeBlock.wouldCollideDown(inactiveBlocks[i])) {
          return false;
        }
      }
      return true;
    }
	
	function clearActiveBlock(block) {						//clears activeBlock for the purpose of movement without ghosting.
		for(var i = 0; i < block.cells.length; i++) {
			ctx.clearRect(block.cells[i].x * CELL_SIZE, block.cells[i].y * CELL_SIZE, 25, 25);
		}
	}

	//************Key input using kibo.js recommened on ibm.com https://github.com/marquete/kibo/blob/master/kibo.js
	
	var k = new Kibo();
	
	k.down(['left'], function () {
	    clearActiveBlock(activeBlock);
		activeBlock.moveLeft();
	    activeBlock.draw();
	});
	k.down(['right'], function () {
	    clearActiveBlock(activeBlock);
		activeBlock.moveRight();
	    activeBlock.draw();
	});
		
    activeBlock.draw();
    var interval = setInterval(function() {
      clearGrid();
      for (var i = 0; i < inactiveBlocks.length; ++i) inactiveBlocks[i].draw();
      if (activeBlock.canDrop()) {
        activeBlock.drop();
      } else {
        inactiveBlocks.push(activeBlock);
        activeBlock = new Block(0);
        if (activeBlock.canDrop() === false) {
          clearInterval(interval);
        }
      }
      activeBlock.draw();
    }, INTERVAL);
	
	


  </script>

</body>
</html>